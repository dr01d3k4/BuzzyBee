// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.GameScreen = (function(_super) {
    __extends(GameScreen, _super);

    function GameScreen(playerControlled) {
      var i, _i;
      this.playerControlled = playerControlled != null ? playerControlled : true;
      this.player = {
        x: PLAYER_START_X,
        y: PLAYER_START_Y,
        width: PLAYER_WIDTH,
        height: PLAYER_HEIGHT,
        velocity: 0,
        acceleration: GRAVITY,
        rotation: 0
      };
      this.firstPipeX = START_PIPE_X;
      this.pipes = [];
      for (i = _i = 0; 0 <= PIPE_COUNT ? _i < PIPE_COUNT : _i > PIPE_COUNT; i = 0 <= PIPE_COUNT ? ++_i : --_i) {
        this.pipes.push(this.newPipe());
      }
      this.score = 0;
      createPlayerCanvas();
      createBackgroundCanvas(Math.random() < DAYTIME_CHANCE);
      this.backgroundScroll = 0;
      createPlaneCanvas();
      this.randomPlane = this.generateRandomPlane();
      this.trail = [];
      this.trail.push([this.player.x, this.player.y + (this.player.height / 2)]);
      this.time = 0;
      this.paused = false;
      this.pauseButton = new Button({
        x: GAME_PAUSE_BUTTON_X + (GAME_SCORE_EXTRA_WIDTH / 2),
        y: GAME_SCORE_Y - (GAME_SCORE_EXTRA_WIDTH / 2),
        width: GAME_PAUSE_BUTTON_WIDTH,
        height: GAME_PAUSE_BUTTON_HEIGHT,
        text: "||",
        hoveredText: "||"
      });
      this.unpauseButton = new Button({
        x: GAME_OVERLAY_X + GAME_OVERLAY_BUTTON_MARGIN,
        y: GAME_OVERLAY_Y + GAME_OVERLAY_HEIGHT - GAME_OVERLAY_BUTTON_MARGIN - GAME_OVERLAY_BUTTON_HEIGHT,
        width: GAME_OVERLAY_BUTTON_WIDTH,
        height: GAME_OVERLAY_BUTTON_HEIGHT,
        text: "Unpause",
        hoveredText: "> Unpause <"
      });
    }

    GameScreen.prototype.randomPipeHeight = function() {
      return randomNumberInclusive(PIPE_MIN_HEIGHT, SCREEN_HEIGHT - PIPE_MIN_HEIGHT - PIPE_GAP_HEIGHT);
    };

    GameScreen.prototype.newPipe = function() {
      return {
        baseHeight: this.randomPipeHeight(),
        gapHeight: PIPE_GAP_HEIGHT,
        width: PIPE_WIDTH,
        scored: false
      };
    };

    GameScreen.prototype.playerJump = function() {
      this.player.velocity = JUMP_VELOCITY;
      return this.player.rotation = PLAYER_JUMP_ROTATION;
    };

    GameScreen.prototype.update = function(deltaTime) {
      var collision, deleteFrom, i, nextPipe, pipe, pipeCenter, trail, x, yDifference, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      this.time += deltaTime;
      if (this.playerControlled) {
        if (isKeyPressed(Key.PAUSE)) {
          this.paused = !this.paused;
          return;
        }
        if (this.paused) {
          this.unpauseButton.update(deltaTime);
          if (this.unpauseButton.clicked) {
            this.paused = false;
          }
          return;
        } else {
          this.pauseButton.update(deltaTime);
          if (this.pauseButton.clicked) {
            this.paused = true;
            return;
          }
        }
      }
      this.player.rotation += PLAYER_ROTATION_SPEED * deltaTime;
      if (this.playerControlled && (isKeyPressed(Key.JUMP) || isMousePressed())) {
        this.playerJump();
      }
      if (!this.playerControlled) {
        nextPipe = null;
        x = this.firstPipeX;
        _ref = this.pipes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pipe = _ref[_i];
          if (x + pipe.width >= this.player.x) {
            nextPipe = pipe;
            break;
          }
          x += pipe.width + PIPE_GAP_HORIZONTAL;
        }
        if (nextPipe != null) {
          pipeCenter = SCREEN_HEIGHT - nextPipe.baseHeight - (nextPipe.gapHeight / 2);
          yDifference = pipeCenter - this.player.y;
          if (yDifference < PLAYER_AI_MIN_Y_DIFFERENCE) {
            this.playerJump();
          }
        }
      }
      this.player.velocity += this.player.acceleration * deltaTime;
      this.player.y += this.player.velocity * deltaTime;
      if (this.player.y + this.player.height > SCREEN_HEIGHT) {
        this.player.y = SCREEN_HEIGHT - this.player.height;
        this.player.velocity = 0;
        if (this.playerControlled) {
          this.gameOver();
        }
      }
      if (this.player.y < 0) {
        this.player.y = 0;
        this.player.velocity = 0;
        if (this.playerControlled) {
          this.gameOver();
        }
      }
      this.firstPipeX -= MOVE_SPEED * deltaTime;
      if (this.firstPipeX < -PIPE_WIDTH * 2) {
        for (i = _j = 1, _ref1 = this.pipes.length; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
          this.pipes[i - 1] = this.pipes[i];
        }
        this.pipes[PIPE_COUNT - 1] = this.newPipe();
        this.firstPipeX += PIPE_WIDTH + PIPE_GAP_HORIZONTAL;
      }
      this.backgroundScroll -= MOVE_SPEED * BACKGROUND_PARALLAX * deltaTime;
      if (this.backgroundScroll < -BACKGROUND_WIDTH) {
        this.backgroundScroll += BACKGROUND_WIDTH;
      }
      _ref2 = this.trail;
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        trail = _ref2[_k];
        trail[0] -= MOVE_SPEED * deltaTime;
      }
      deleteFrom = -1;
      for (i = _l = _ref3 = this.trail.length - 1; _l >= 0; i = _l += -1) {
        if (this.trail[i][0] < 0) {
          deleteFrom = i - 1;
          break;
        }
      }
      if (deleteFrom >= 0) {
        this.trail.splice(0, deleteFrom + 1);
      }
      this.trail.push([this.player.x, this.player.y + (this.player.height / 2)]);
      if (this.player.rotation < -PLAYER_MAX_ROTATION) {
        this.player.rotation = -PLAYER_MAX_ROTATION;
      }
      if (this.player.rotation > PLAYER_MAX_ROTATION) {
        this.player.rotation = PLAYER_MAX_ROTATION;
      }
      x = this.firstPipeX;
      collision = false;
      _ref4 = this.pipes;
      for (_m = 0, _len2 = _ref4.length; _m < _len2; _m++) {
        pipe = _ref4[_m];
        if (x < this.player.x + this.player.width) {
          if (x + pipe.width > this.player.x && (this.player.y + this.player.height > SCREEN_HEIGHT - pipe.baseHeight || this.player.y < SCREEN_HEIGHT - pipe.baseHeight - pipe.gapHeight)) {
            collision = true;
            break;
          }
          if (x + pipe.width <= this.player.x) {
            if (!pipe.scored) {
              this.score += 1;
            }
            pipe.scored = true;
          }
        }
        x += pipe.width + PIPE_GAP_HORIZONTAL;
      }
      if (collision && this.playerControlled) {
        return this.gameOver();
      }
      this.randomPlane.x -= RANDOM_PLANE_SPEED * deltaTime;
      if (this.randomPlane.x + this.randomPlane.width + RANDOM_PLANE_TRAIL_LENGTH < 0) {
        return this.randomPlane = this.generateRandomPlane();
      }
    };

    GameScreen.prototype.generateRandomPlane = function() {
      return {
        x: randomNumberInclusive(RANDOM_PLANE_MIN_X, RANDOM_PLANE_MAX_X),
        y: randomNumberInclusive(RANDOM_PLANE_MIN_Y, RANDOM_PLANE_MAX_Y),
        width: RANDOM_PLANE_WIDTH,
        height: RANDOM_PLANE_HEIGHT
      };
    };

    GameScreen.prototype.gameOver = function() {
      return changeScreen(new GameOverScreen(this.score, this.backgroundScroll));
    };

    GameScreen.prototype.render = function(context) {
      var i, pipe, scoreText, x, _i, _j, _len, _ref, _ref1;
      context.fillStyle = "#ffffff";
      context.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      context.drawImage(backgroundCanvas, Math.floor(this.backgroundScroll), 0);
      context.drawImage(backgroundCanvas, Math.floor(this.backgroundScroll + BACKGROUND_WIDTH), 0);
      if (this.randomPlane.x < CANVAS_WIDTH) {
        context.drawImage(planeCanvas, this.randomPlane.x, this.randomPlane.y);
        context.fillStyle = "#ffffff";
        context.fillRect(this.randomPlane.x, this.randomPlane.y + (this.randomPlane.height * 0.75), RANDOM_PLANE_TRAIL_LENGTH, RANDOM_PLANE_TRAIL_THICKNESS);
      }
      context.fillStyle = Colour.PIPE;
      x = this.firstPipeX;
      _ref = this.pipes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pipe = _ref[_i];
        if (x > CANVAS_WIDTH) {
          break;
        }
        context.fillRect(x, SCREEN_HEIGHT - pipe.baseHeight, PIPE_WIDTH, pipe.baseHeight);
        context.fillRect(x, 0, PIPE_WIDTH, SCREEN_HEIGHT - (pipe.baseHeight + pipe.gapHeight));
        x += pipe.width + PIPE_GAP_HORIZONTAL;
      }
      if (this.trail.length >= 1) {
        context.strokeStyle = Colour.PLAYER;
        context.fillStyle = Colour.PLAYER;
        context.lineWidth = PLAYER_TRAIL_THICKNESS;
        context.beginPath();
        context.moveTo(this.trail[0][0], this.trail[0][1]);
        if (this.trail.length >= 2) {
          for (i = _j = 1, _ref1 = this.trail.length; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
            context.lineTo(this.trail[i][0], this.trail[i][1]);
          }
        }
        context.lineTo(this.player.x, this.player.y + (this.player.height / 2));
        context.lineTo(this.player.x + 8, this.player.y + (this.player.height / 2));
        context.stroke();
      }
      context.translate(this.player.x, this.player.y + (this.player.height / 2));
      context.rotate(this.player.rotation * Math.PI / 180);
      context.drawImage(playerCanvas, 0, -this.player.height / 2);
      context.rotate(-this.player.rotation * Math.PI / 180);
      context.translate(-this.player.x, -(this.player.y + (this.player.height / 2)));
      if (this.playerControlled) {
        context.font = BODY_FONT;
        context.textAlign = "left";
        context.textBaseline = "top";
        scoreText = "Score: " + this.score;
        context.fillStyle = Colour.TEXT_BACKGROUND;
        context.fillRect(GAME_SCORE_X - (GAME_SCORE_EXTRA_WIDTH / 2), GAME_SCORE_Y - (GAME_SCORE_EXTRA_WIDTH / 2), context.measureText(scoreText).width + GAME_SCORE_EXTRA_WIDTH, GAME_SCORE_HEIGHT);
        context.beginPath();
        context.strokeStyle = Colour.TEXT;
        context.lineWidth = OUTLINE_THICKNESS;
        context.rect(GAME_SCORE_X - (GAME_SCORE_EXTRA_WIDTH / 2), GAME_SCORE_Y - (GAME_SCORE_EXTRA_WIDTH / 2), context.measureText(scoreText).width + GAME_SCORE_EXTRA_WIDTH, GAME_SCORE_HEIGHT);
        context.stroke();
        context.fillStyle = Colour.TEXT;
        context.fillText(scoreText, GAME_SCORE_X, GAME_SCORE_Y);
        if (this.paused) {
          context.fillStyle = Colour.TEXT_BACKGROUND;
          context.fillRect(GAME_OVERLAY_X, GAME_OVERLAY_Y, GAME_OVERLAY_WIDTH, GAME_OVERLAY_HEIGHT);
          context.beginPath();
          context.strokeStyle = Colour.TEXT;
          context.lineWidth = OUTLINE_THICKNESS;
          context.rect(GAME_OVERLAY_X, GAME_OVERLAY_Y, GAME_OVERLAY_WIDTH, GAME_OVERLAY_HEIGHT);
          context.stroke();
          context.fillStyle = Colour.TEXT;
          context.font = GAME_OVERLAY_TITLE_FONT;
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText("Paused", GAME_OVERLAY_TITLE_TEXT_X, GAME_OVERLAY_TITLE_TEXT_Y);
          context.font = BODY_FONT;
          context.fillText("Press P or Esc to unpause", GAME_OVERLAY_BODY_TEXT_X, GAME_OVERLAY_BODY_TEXT_Y);
          return this.unpauseButton.render(context);
        } else {
          return this.pauseButton.render(context);
        }
      }
    };

    return GameScreen;

  })(Screen);

}).call(this);
